{"ast":null,"code":"import React, { useImperativeHandle, useState, useContext, useEffect, useRef, useCallback, forwardRef } from 'react';\nimport { getEmptyImage } from 'react-dnd-html5-backend';\nimport { DndProvider } from 'react-dnd-multi-backend';\nimport HTML5toTouch from 'react-dnd-multi-backend/dist/cjs/HTML5toTouch';\nimport { produce } from 'immer';\nimport { useDrag, useDrop, useDragLayer, useDragDropManager } from 'react-dnd';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __spreadArray(to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n}\n\nvar compareItems = function compareItems(a, b) {\n  if (a.text > b.text) {\n    return 1;\n  } else if (a.text < b.text) {\n    return -1;\n  }\n\n  return 0;\n};\n\nvar getTreeItem = function getTreeItem(tree, id) {\n  var node = tree.find(function (n) {\n    return n.id === id;\n  });\n\n  if (!node) {\n    return undefined;\n  } // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  return produce(node, function () {});\n};\n\nvar isAncestor = function isAncestor(tree, sourceId, targetId) {\n  if (targetId === 0) {\n    return false;\n  }\n\n  var targetNode = tree.find(function (node) {\n    return node.id === targetId;\n  });\n\n  if (targetNode === undefined) {\n    return false;\n  }\n\n  if (targetNode.parent === sourceId) {\n    return true;\n  }\n\n  return isAncestor(tree, sourceId, targetNode.parent);\n};\n\nvar isDroppable = function isDroppable(dragSourceId, dropTargetId, treeContext) {\n  var tree = treeContext.tree,\n      rootId = treeContext.rootId,\n      canDrop = treeContext.canDrop;\n\n  if (dragSourceId === undefined) {\n    if (dropTargetId === rootId) {\n      return true;\n    }\n\n    var dropTargetNode = tree.find(function (node) {\n      return node.id === dropTargetId;\n    });\n\n    if (dropTargetNode && dropTargetNode.droppable) {\n      return true;\n    }\n\n    return false;\n  } else {\n    if (canDrop) {\n      var result = canDrop(dragSourceId, dropTargetId);\n\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    if (dragSourceId === dropTargetId) {\n      return false;\n    }\n\n    var dragSourceNode = tree.find(function (node) {\n      return node.id === dragSourceId;\n    });\n\n    if (dragSourceNode === undefined || dragSourceNode.parent === dropTargetId) {\n      return false;\n    }\n\n    if (dropTargetId === rootId) {\n      return true;\n    }\n\n    var dropTargetNode = tree.find(function (node) {\n      return node.id === dropTargetId;\n    });\n\n    if (dropTargetNode === undefined || !dropTargetNode.droppable) {\n      return false;\n    }\n\n    return !isAncestor(tree, dragSourceId, dropTargetId);\n  }\n};\n\nvar getDestinationIndex = function getDestinationIndex(tree, dropTargetId, index) {\n  if (index === 0) {\n    return 0;\n  }\n\n  var siblings = tree.filter(function (node) {\n    return node.parent === dropTargetId;\n  });\n\n  if (siblings[index]) {\n    return tree.findIndex(function (node) {\n      return node.id === siblings[index].id;\n    });\n  }\n\n  return tree.findIndex(function (node) {\n    return node.id === siblings[index - 1].id;\n  }) + 1;\n};\n\nvar arrayMoveMutable = function arrayMoveMutable(array, fromIndex, toIndex) {\n  var startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex;\n\n  if (startIndex >= 0 && startIndex < array.length) {\n    var endIndex = toIndex < 0 ? array.length + toIndex : toIndex;\n    var item = array.splice(fromIndex, 1)[0];\n    array.splice(endIndex, 0, item);\n  }\n};\n\nvar arrayMoveImmutable = function arrayMoveImmutable(array, fromIndex, toIndex) {\n  array = __spreadArray([], array);\n  arrayMoveMutable(array, fromIndex, toIndex);\n  return array;\n};\n\nvar mutateTree = function mutateTree(tree, dragSourceId, dropTargetId, index) {\n  var srcIndex = tree.findIndex(function (node) {\n    return node.id === dragSourceId;\n  });\n  var destIndex = getDestinationIndex(tree, dropTargetId, index);\n  var newTree;\n\n  if (destIndex > srcIndex) {\n    newTree = arrayMoveImmutable(tree, srcIndex, destIndex - 1);\n  } else {\n    newTree = arrayMoveImmutable(tree, srcIndex, destIndex);\n  }\n\n  return produce(newTree, function (draft) {\n    draft.forEach(function (node) {\n      if (node.id === dragSourceId) {\n        node.parent = dropTargetId;\n      }\n    });\n  });\n};\n\nvar compareYCoord = function compareYCoord(el, pointerY) {\n  var bbox = el.getBoundingClientRect();\n  var centerY = bbox.top + bbox.height / 2;\n  return pointerY > centerY ? \"down\" : \"up\";\n};\n\nvar getInnerIndex = function getInnerIndex(listItems, monitor) {\n  var pos = \"\";\n  var index = 0;\n  listItems.forEach(function (el, key) {\n    var _a;\n\n    var flag = compareYCoord(el, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0);\n\n    if (pos === \"\") {\n      pos = flag;\n    } else if (pos !== flag) {\n      pos = flag;\n      index = key;\n    }\n\n    if (key === listItems.length - 1 && flag === \"down\") {\n      index = key + 1;\n    }\n  });\n  return index;\n};\n\nvar getOuterIndex = function getOuterIndex(node, nodeEl, monitor) {\n  var parentList = nodeEl.closest('[role=\"list\"]');\n  var parentListItems = parentList === null || parentList === void 0 ? void 0 : parentList.querySelectorAll(':scope > [role=\"listitem\"]');\n\n  if (!parentListItems) {\n    return null;\n  }\n\n  return getInnerIndex(parentListItems, monitor);\n};\n\nvar getHoverPosition = function getHoverPosition(el, pointerY, context) {\n  var bbox = el.getBoundingClientRect();\n  var offsetY = context.dropTargetOffset;\n  var upSideY = bbox.top + offsetY;\n  var lowerSideY = bbox.bottom - offsetY;\n\n  if (pointerY > lowerSideY) {\n    return \"lower\";\n  } else if (pointerY < upSideY) {\n    return \"upper\";\n  }\n\n  return \"middle\";\n};\n\nvar getDropTarget = function getDropTarget(node, nodeEl, monitor, context) {\n  var _a;\n\n  if (!nodeEl) {\n    return null;\n  }\n\n  if (node === null) {\n    var listItems = nodeEl.querySelectorAll(':scope > [role=\"listitem\"]');\n    return {\n      id: context.rootId,\n      index: getInnerIndex(listItems, monitor)\n    };\n  }\n\n  var dragSource = monitor.getItem();\n  var list = nodeEl.querySelector('[role=\"list\"]');\n  var hoverPosition = getHoverPosition(nodeEl, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0, context);\n\n  if (!list) {\n    if (hoverPosition === \"middle\") {\n      return {\n        id: node.id,\n        index: 0\n      };\n    }\n\n    if (isDroppable(dragSource.id, node.parent, context)) {\n      var outerIndex = getOuterIndex(node, nodeEl, monitor);\n\n      if (outerIndex === null) {\n        return null;\n      }\n\n      return {\n        id: node.parent,\n        index: outerIndex\n      };\n    }\n\n    return null;\n  } else {\n    if (hoverPosition === \"upper\") {\n      if (isDroppable(dragSource.id, node.parent, context)) {\n        var outerIndex = getOuterIndex(node, nodeEl, monitor);\n\n        if (outerIndex === null) {\n          return null;\n        }\n\n        return {\n          id: node.parent,\n          index: outerIndex\n        };\n      } else {\n        return {\n          id: node.id,\n          index: 0\n        };\n      }\n    }\n\n    var listItems = list.querySelectorAll(':scope > [role=\"listitem\"]');\n    return {\n      id: node.id,\n      index: getInnerIndex(listItems, monitor)\n    };\n  }\n};\n\nvar TreeContext = React.createContext({});\n\nvar TreeProvider = function TreeProvider(props) {\n  var _a = useOpenIdsHelper(props.tree, props.initialOpen),\n      openIds = _a[0],\n      _b = _a[1],\n      handleToggle = _b.handleToggle,\n      handleCloseAll = _b.handleCloseAll,\n      handleOpenAll = _b.handleOpenAll,\n      handleOpen = _b.handleOpen,\n      handleClose = _b.handleClose;\n\n  useImperativeHandle(props.treeRef, function () {\n    return {\n      open: function open(targetIds) {\n        return handleOpen(targetIds);\n      },\n      close: function close(targetIds) {\n        return handleClose(targetIds);\n      },\n      openAll: function openAll() {\n        return handleOpenAll();\n      },\n      closeAll: function closeAll() {\n        return handleCloseAll();\n      }\n    };\n  });\n  var canDropCallback = props.canDrop;\n  var canDragCallback = props.canDrag;\n\n  var value = _assign(_assign({\n    listComponent: \"ul\",\n    listItemComponent: \"li\",\n    placeholderComponent: \"li\",\n    sort: true,\n    insertDroppableFirst: true,\n    dropTargetOffset: 0,\n    initialOpen: false\n  }, props), {\n    openIds: openIds,\n    onDrop: function onDrop(id, parentId, index) {\n      return props.onDrop(mutateTree(props.tree, id, parentId, index), {\n        dragSourceId: id,\n        dropTargetId: parentId,\n        dragSource: getTreeItem(props.tree, id),\n        dropTarget: getTreeItem(props.tree, parentId)\n      });\n    },\n    canDrop: canDropCallback ? function (id, parentId) {\n      return canDropCallback(props.tree, {\n        dragSourceId: id,\n        dropTargetId: parentId,\n        dragSource: getTreeItem(props.tree, id),\n        dropTarget: getTreeItem(props.tree, parentId)\n      });\n    } : undefined,\n    canDrag: canDragCallback ? function (id) {\n      return canDragCallback(getTreeItem(props.tree, id));\n    } : undefined,\n    onToggle: handleToggle\n  });\n\n  return React.createElement(TreeContext.Provider, {\n    value: value\n  }, props.children);\n};\n\nvar DragControlContext = React.createContext({});\nvar initialState$1 = {\n  isLock: false\n};\n\nvar DragControlProvider = function DragControlProvider(props) {\n  var _a = useState(initialState$1.isLock),\n      isLock = _a[0],\n      setIsLock = _a[1];\n\n  return React.createElement(DragControlContext.Provider, {\n    value: {\n      isLock: isLock,\n      lock: function lock() {\n        return setIsLock(true);\n      },\n      unlock: function unlock() {\n        return setIsLock(false);\n      }\n    }\n  }, props.children);\n};\n\nvar PlaceholderContext = React.createContext({});\nvar initialState = {\n  dropTargetId: undefined,\n  index: undefined\n};\n\nvar PlaceholderProvider = function PlaceholderProvider(props) {\n  var _a = useState(initialState.dropTargetId),\n      dropTargetId = _a[0],\n      setDropTargetId = _a[1];\n\n  var _b = useState(initialState.index),\n      index = _b[0],\n      setIndex = _b[1];\n\n  var showPlaceholder = function showPlaceholder(dropTargetId, index) {\n    setDropTargetId(dropTargetId);\n    setIndex(index);\n  };\n\n  var hidePlaceholder = function hidePlaceholder() {\n    setDropTargetId(initialState.dropTargetId);\n    setIndex(initialState.index);\n  };\n\n  return React.createElement(PlaceholderContext.Provider, {\n    value: {\n      dropTargetId: dropTargetId,\n      index: index,\n      showPlaceholder: showPlaceholder,\n      hidePlaceholder: hidePlaceholder\n    }\n  }, props.children);\n};\n\nvar Providers = function Providers(props) {\n  return React.createElement(TreeProvider, _assign({}, props), React.createElement(DragControlProvider, null, React.createElement(PlaceholderProvider, null, React.createElement(DndProvider, {\n    options: HTML5toTouch\n  }, props.children))));\n};\n/**\n * This is a hook to allow text selection by mouse in the text input area in a node.\n * Temporarily disables node dragging while the pointer is over the text input area.\n */\n\n\nvar useDragControl = function useDragControl(ref) {\n  var dragControlContext = useContext(DragControlContext);\n\n  var lock = function lock(e) {\n    var target = e.target;\n\n    if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n      dragControlContext.lock();\n    }\n  };\n\n  var unlock = function unlock(e) {\n    var target = e.target;\n\n    if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n      dragControlContext.unlock();\n    }\n  };\n\n  var handleMouseOver = function handleMouseOver(e) {\n    return lock(e);\n  };\n\n  var handleMouseOut = function handleMouseOut(e) {\n    return unlock(e);\n  };\n\n  var handleFocusIn = function handleFocusIn(e) {\n    return lock(e);\n  };\n\n  var handleFocusOut = function handleFocusOut(e) {\n    return unlock(e);\n  };\n\n  useEffect(function () {\n    var _a, _b, _c, _d;\n\n    (_a = ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener(\"mouseover\", handleMouseOver);\n    (_b = ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener(\"mouseout\", handleMouseOut);\n    (_c = ref.current) === null || _c === void 0 ? void 0 : _c.addEventListener(\"focusin\", handleFocusIn);\n    (_d = ref.current) === null || _d === void 0 ? void 0 : _d.addEventListener(\"focusout\", handleFocusOut);\n    return function () {\n      var _a, _b, _c, _d;\n\n      (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"mouseover\", handleMouseOver);\n      (_b = ref.current) === null || _b === void 0 ? void 0 : _b.removeEventListener(\"mouseout\", handleMouseOut);\n      (_c = ref.current) === null || _c === void 0 ? void 0 : _c.removeEventListener(\"focusin\", handleFocusIn);\n      (_d = ref.current) === null || _d === void 0 ? void 0 : _d.removeEventListener(\"focusout\", handleFocusOut);\n    };\n  }, []);\n  useEffect(function () {\n    var _a;\n\n    (_a = ref.current) === null || _a === void 0 ? void 0 : _a.setAttribute(\"draggable\", dragControlContext.isLock ? \"false\" : \"true\");\n  }, [dragControlContext.isLock]);\n};\n\nvar ItemTypes = {\n  TREE_ITEM: Symbol()\n};\nvar dragSourceElement = null;\n\nvar useDragNode = function useDragNode(item, ref) {\n  var treeContext = useTreeContext();\n\n  var register = function register(e) {\n    var target = e.target;\n\n    if (target instanceof HTMLElement) {\n      var source = target.closest('[role=\"listitem\"]');\n\n      if (e.currentTarget === source) {\n        dragSourceElement = source;\n      }\n    }\n  };\n\n  var handleDragStart = function handleDragStart(e) {\n    return register(e);\n  };\n\n  var handleTouchStart = function handleTouchStart(e) {\n    return register(e);\n  };\n\n  useEffect(function () {\n    var _a, _b;\n\n    (_a = ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener(\"dragstart\", handleDragStart);\n    (_b = ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener(\"touchstart\", handleTouchStart, {\n      passive: true\n    });\n    return function () {\n      var _a, _b;\n\n      (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"dragstart\", handleDragStart);\n      (_b = ref.current) === null || _b === void 0 ? void 0 : _b.removeEventListener(\"touchstart\", handleTouchStart);\n    };\n  }, []);\n\n  var _a = useDrag({\n    type: ItemTypes.TREE_ITEM,\n    item: _assign({\n      ref: ref\n    }, item),\n    canDrag: function canDrag() {\n      var canDrag = treeContext.canDrag;\n\n      if (dragSourceElement !== ref.current) {\n        return false;\n      }\n\n      if (canDrag) {\n        return canDrag(item.id);\n      }\n\n      return true;\n    },\n    collect: function collect(monitor) {\n      return {\n        isDragging: monitor.isDragging()\n      };\n    }\n  }),\n      isDragging = _a[0].isDragging,\n      drag = _a[1],\n      preview = _a[2];\n\n  return [isDragging, drag, preview];\n};\n\nvar useDragOver = function useDragOver(id, isOpen, dragOverHandler) {\n  var stack = useRef(0);\n  var timer = useRef(0);\n\n  var onDragEnter = function onDragEnter() {\n    stack.current += 1;\n\n    if (stack.current === 1 && !isOpen) {\n      timer.current = window.setTimeout(function () {\n        return dragOverHandler(id);\n      }, 500);\n    }\n  };\n\n  var onDragLeave = function onDragLeave() {\n    stack.current -= 1;\n\n    if (stack.current === 0) {\n      window.clearTimeout(timer.current);\n    }\n  };\n\n  var onDrop = function onDrop() {\n    if (timer.current > 0) {\n      window.clearTimeout(timer.current);\n    }\n\n    stack.current = 0;\n    timer.current = 0;\n  };\n\n  return {\n    onDragEnter: onDragEnter,\n    onDragLeave: onDragLeave,\n    onDrop: onDrop\n  };\n};\n\nvar useDropRoot = function useDropRoot(ref) {\n  var treeContext = useTreeContext();\n  var placeholderContext = useContext(PlaceholderContext);\n\n  var _a = useDrop({\n    accept: ItemTypes.TREE_ITEM,\n    drop: function drop(item, monitor) {\n      var rootId = treeContext.rootId,\n          onDrop = treeContext.onDrop;\n      var dropTargetId = placeholderContext.dropTargetId,\n          index = placeholderContext.index;\n\n      if (monitor.isOver({\n        shallow: true\n      }) && dropTargetId !== undefined && index !== undefined) {\n        onDrop(item.id, rootId, index);\n      }\n\n      placeholderContext.hidePlaceholder();\n    },\n    canDrop: function canDrop(item, monitor) {\n      var rootId = treeContext.rootId;\n\n      if (monitor.isOver({\n        shallow: true\n      })) {\n        if (item === undefined) {\n          return false;\n        }\n\n        return isDroppable(item.id, rootId, treeContext);\n      }\n\n      return false;\n    },\n    hover: function hover(dragItem, monitor) {\n      if (monitor.isOver({\n        shallow: true\n      })) {\n        var rootId = treeContext.rootId;\n        var dropTargetId = placeholderContext.dropTargetId,\n            index = placeholderContext.index,\n            showPlaceholder = placeholderContext.showPlaceholder,\n            hidePlaceholder = placeholderContext.hidePlaceholder;\n        var dropTarget = getDropTarget(null, ref.current, monitor, treeContext);\n\n        if (dropTarget === null || !isDroppable(dragItem.id, rootId, treeContext)) {\n          hidePlaceholder();\n          return;\n        }\n\n        if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n          showPlaceholder(dropTarget.id, dropTarget.index);\n        }\n      }\n    },\n    collect: function collect(monitor) {\n      return {\n        isOver: monitor.isOver({\n          shallow: true\n        }) && monitor.canDrop(),\n        dragSource: monitor.getItem()\n      };\n    }\n  }),\n      _b = _a[0],\n      isOver = _b.isOver,\n      dragSource = _b.dragSource,\n      drop = _a[1];\n\n  return [isOver, dragSource, drop];\n};\n\nvar useDropNode = function useDropNode(item, ref) {\n  var treeContext = useTreeContext();\n  var placeholderContext = useContext(PlaceholderContext);\n\n  var _a = useDrop({\n    accept: ItemTypes.TREE_ITEM,\n    drop: function drop(dragSource, monitor) {\n      var dropTargetId = placeholderContext.dropTargetId,\n          index = placeholderContext.index;\n\n      if (monitor.isOver({\n        shallow: true\n      }) && dropTargetId !== undefined && index !== undefined) {\n        treeContext.onDrop(dragSource.id, dropTargetId, index);\n      }\n\n      placeholderContext.hidePlaceholder();\n    },\n    canDrop: function canDrop(dragSource, monitor) {\n      if (monitor.isOver({\n        shallow: true\n      })) {\n        var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n\n        if (dropTarget === null) {\n          return false;\n        }\n\n        return isDroppable(dragSource.id, dropTarget.id, treeContext);\n      }\n\n      return false;\n    },\n    hover: function hover(dragSource, monitor) {\n      if (monitor.isOver({\n        shallow: true\n      })) {\n        var dropTargetId = placeholderContext.dropTargetId,\n            index = placeholderContext.index,\n            showPlaceholder = placeholderContext.showPlaceholder,\n            hidePlaceholder = placeholderContext.hidePlaceholder;\n        var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n\n        if (dropTarget === null || !isDroppable(dragSource.id, dropTarget.id, treeContext)) {\n          hidePlaceholder();\n          return;\n        }\n\n        if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n          showPlaceholder(dropTarget.id, dropTarget.index);\n        }\n      }\n    },\n    collect: function collect(monitor) {\n      return {\n        isOver: monitor.isOver({\n          shallow: true\n        }) && monitor.canDrop(),\n        dragSource: monitor.getItem()\n      };\n    }\n  }),\n      _b = _a[0],\n      isOver = _b.isOver,\n      dragSource = _b.dragSource,\n      drop = _a[1];\n\n  return [isOver, dragSource, drop];\n};\n\nvar useOpenIdsHelper = function useOpenIdsHelper(tree, initialOpen) {\n  var initialOpenIds = [];\n\n  if (initialOpen === true) {\n    initialOpenIds = tree.filter(function (node) {\n      return node.droppable;\n    }).map(function (node) {\n      return node.id;\n    });\n  } else if (Array.isArray(initialOpen)) {\n    initialOpenIds = initialOpen;\n  }\n\n  var _a = useState(initialOpenIds),\n      openIds = _a[0],\n      setOpenIds = _a[1];\n\n  var handleToggle = useCallback(function (targetId) {\n    if (openIds.includes(targetId)) {\n      setOpenIds(openIds.filter(function (id) {\n        return id !== targetId;\n      }));\n      return;\n    }\n\n    setOpenIds(__spreadArray(__spreadArray([], openIds), [targetId]));\n  }, [openIds]);\n  var handleCloseAll = useCallback(function () {\n    return setOpenIds([]);\n  }, []);\n  var handleOpenAll = useCallback(function () {\n    return setOpenIds(tree.filter(function (node) {\n      return node.droppable;\n    }).map(function (node) {\n      return node.id;\n    }));\n  }, [tree]);\n  var handleOpen = useCallback(function (targetIds) {\n    return setOpenIds(__spreadArray(__spreadArray([], openIds), tree.filter(function (node) {\n      return node.droppable && (Array.isArray(targetIds) ? targetIds.includes(node.id) : node.id === targetIds);\n    }).map(function (node) {\n      return node.id;\n    })).filter(function (value, index, self) {\n      return self.indexOf(value) === index;\n    }));\n  }, [tree, openIds]);\n  var handleClose = useCallback(function (targetIds) {\n    return setOpenIds(openIds.filter(function (id) {\n      return Array.isArray(targetIds) ? !targetIds.includes(id) : id !== targetIds;\n    }));\n  }, [tree, openIds]);\n  return [openIds, {\n    handleToggle: handleToggle,\n    handleCloseAll: handleCloseAll,\n    handleOpenAll: handleOpenAll,\n    handleOpen: handleOpen,\n    handleClose: handleClose\n  }];\n};\n\nvar useTreeDragLayer = function useTreeDragLayer() {\n  return useDragLayer(function (monitor) {\n    var itemType = monitor.getItemType();\n    return {\n      item: monitor.getItem(),\n      clientOffset: monitor.getClientOffset(),\n      isDragging: monitor.isDragging() && itemType === ItemTypes.TREE_ITEM\n    };\n  });\n};\n\nvar useTreeContext = function useTreeContext() {\n  var treeContext = useContext(TreeContext);\n\n  if (!treeContext) {\n    throw new Error(\"useTreeContext must be used under TreeProvider\");\n  }\n\n  return treeContext;\n};\n\nvar Node = function Node(props) {\n  var context = useTreeContext();\n  var ref = useRef(null);\n  var item = context.tree.find(function (node) {\n    return node.id === props.id;\n  });\n  var openIds = context.openIds,\n      classes = context.classes;\n  var open = openIds.includes(props.id);\n\n  if (!item) {\n    return null;\n  }\n\n  var _a = useDragNode(item, ref),\n      isDragging = _a[0],\n      drag = _a[1],\n      preview = _a[2];\n\n  var _b = useDropNode(item, ref),\n      isOver = _b[0],\n      dragSource = _b[1],\n      drop = _b[2];\n\n  drag(ref);\n\n  if (isDroppable(dragSource === null || dragSource === void 0 ? void 0 : dragSource.id, props.id, context)) {\n    drop(ref);\n  }\n\n  var hasChild = !!context.tree.find(function (node) {\n    return node.parent === props.id;\n  });\n  useEffect(function () {\n    if (context.dragPreviewRender) {\n      preview(getEmptyImage(), {\n        captureDraggingState: true\n      });\n    }\n  }, []);\n  useDragControl(ref);\n  var handleToggle = useCallback(function () {\n    context.onToggle(item.id);\n  }, [openIds]);\n  var Component = context.listItemComponent;\n  var className = \"\";\n\n  if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n    className = classes.dropTarget;\n  }\n\n  if (isDragging && (classes === null || classes === void 0 ? void 0 : classes.draggingSource)) {\n    className = className + \" \" + classes.draggingSource;\n  }\n\n  var draggable = context.canDrag ? context.canDrag(props.id) : true;\n  var params = {\n    depth: props.depth,\n    isOpen: open,\n    draggable: draggable,\n    hasChild: hasChild,\n    onToggle: handleToggle\n  };\n  return React.createElement(Component, {\n    ref: ref,\n    className: className,\n    role: \"listitem\"\n  }, context.render(item, params), open && hasChild && React.createElement(Container, {\n    parentId: props.id,\n    depth: props.depth + 1\n  }));\n};\n\nvar Placeholder = function Placeholder(props) {\n  var _a = useTreeContext(),\n      placeholderRender = _a.placeholderRender,\n      Component = _a.placeholderComponent,\n      classes = _a.classes;\n\n  var placeholderContext = useContext(PlaceholderContext);\n  var manager = useDragDropManager();\n  var monitor = manager.getMonitor();\n  var dragSource = monitor.getItem();\n\n  if (!placeholderRender || !dragSource) {\n    return null;\n  }\n\n  var visible = props.dropTargetId === placeholderContext.dropTargetId && (props.index === placeholderContext.index || props.index === undefined && props.listCount === placeholderContext.index);\n\n  if (!visible) {\n    return null;\n  }\n\n  return React.createElement(Component, {\n    className: (classes === null || classes === void 0 ? void 0 : classes.placeholder) || \"\"\n  }, placeholderRender(dragSource, {\n    depth: props.depth\n  }));\n};\n\nvar Container = function Container(props) {\n  var treeContext = useTreeContext();\n  var ref = useRef(null);\n  var nodes = treeContext.tree.filter(function (l) {\n    return l.parent === props.parentId;\n  });\n  var view = nodes;\n  var sortCallback = typeof treeContext.sort === \"function\" ? treeContext.sort : compareItems;\n\n  if (treeContext.insertDroppableFirst) {\n    var droppableNodes = nodes.filter(function (n) {\n      return n.droppable;\n    });\n    var nonDroppableNodes = nodes.filter(function (n) {\n      return !n.droppable;\n    });\n\n    if (treeContext.sort === false) {\n      view = __spreadArray(__spreadArray([], droppableNodes), nonDroppableNodes);\n    } else {\n      droppableNodes = droppableNodes.sort(sortCallback);\n      nonDroppableNodes = nonDroppableNodes.sort(sortCallback);\n      view = __spreadArray(__spreadArray([], droppableNodes), nonDroppableNodes);\n    }\n  } else {\n    if (treeContext.sort !== false) {\n      view = nodes.sort(sortCallback);\n    }\n  }\n\n  var _a = useDropRoot(ref),\n      isOver = _a[0],\n      dragSource = _a[1],\n      drop = _a[2];\n\n  var classes = treeContext.classes;\n\n  if (props.parentId === treeContext.rootId && isDroppable(dragSource === null || dragSource === void 0 ? void 0 : dragSource.id, treeContext.rootId, treeContext)) {\n    drop(ref);\n  }\n\n  var className = \"\";\n\n  if (classes === null || classes === void 0 ? void 0 : classes.container) {\n    className = classes.container;\n  }\n\n  if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n    className = className + \" \" + classes.dropTarget;\n  }\n\n  if (props.parentId === 0 && (classes === null || classes === void 0 ? void 0 : classes.root)) {\n    className = className + \" \" + classes.root;\n  }\n\n  var Component = treeContext.listComponent;\n  return React.createElement(Component, {\n    ref: ref,\n    className: className,\n    role: \"list\"\n  }, view.map(function (node, index) {\n    return React.createElement(React.Fragment, {\n      key: node.id\n    }, React.createElement(Placeholder, {\n      depth: props.depth,\n      listCount: view.length,\n      dropTargetId: props.parentId,\n      index: index\n    }), React.createElement(Node, {\n      id: node.id,\n      depth: props.depth\n    }));\n  }), React.createElement(Placeholder, {\n    depth: props.depth,\n    listCount: view.length,\n    dropTargetId: props.parentId\n  }));\n};\n\nvar rootStyle = {\n  height: \"100%\",\n  left: 0,\n  pointerEvents: \"none\",\n  position: \"fixed\",\n  top: 0,\n  width: \"100%\",\n  zIndex: 100\n};\n\nvar getItemStyles = function getItemStyles(monitorProps) {\n  var offset = monitorProps.clientOffset;\n\n  if (!offset) {\n    return {};\n  }\n\n  var x = offset.x,\n      y = offset.y;\n  var transform = \"translate(\" + x + \"px, \" + y + \"px)\";\n  return {\n    pointerEvents: \"none\",\n    transform: transform\n  };\n};\n\nvar DragLayer = function DragLayer() {\n  var context = useTreeContext();\n  var monitorProps = useTreeDragLayer();\n\n  if (!monitorProps.isDragging) {\n    return null;\n  }\n\n  return React.createElement(\"div\", {\n    style: rootStyle\n  }, React.createElement(\"div\", {\n    style: getItemStyles(monitorProps)\n  }, context.dragPreviewRender && context.dragPreviewRender(monitorProps)));\n};\n\nfunction TreeInner(props, ref) {\n  return React.createElement(Providers, _assign({}, props, {\n    treeRef: ref\n  }), props.dragPreviewRender && React.createElement(DragLayer, null), React.createElement(Container, {\n    parentId: props.rootId,\n    depth: 0\n  }));\n}\n\nvar Tree = forwardRef(TreeInner);\nexport { Container, DragLayer, ItemTypes, Node, Tree, compareItems, getDropTarget, getTreeItem, isAncestor, isDroppable, mutateTree, useDragControl, useDragNode, useDragOver, useDropNode, useDropRoot, useOpenIdsHelper, useTreeContext, useTreeDragLayer };","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["import React, { useImperativeHandle, useState, useContext, useEffect, useRef, useCallback, forwardRef } from 'react';\nimport { getEmptyImage } from 'react-dnd-html5-backend';\nimport { DndProvider } from 'react-dnd-multi-backend';\nimport HTML5toTouch from 'react-dnd-multi-backend/dist/cjs/HTML5toTouch';\nimport { produce } from 'immer';\nimport { useDrag, useDrop, useDragLayer, useDragDropManager } from 'react-dnd';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\n\nvar compareItems = function (a, b) {\n    if (a.text > b.text) {\n        return 1;\n    }\n    else if (a.text < b.text) {\n        return -1;\n    }\n    return 0;\n};\n\nvar getTreeItem = function (tree, id) {\n    var node = tree.find(function (n) { return n.id === id; });\n    if (!node) {\n        return undefined;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    return produce(node, function () { });\n};\n\nvar isAncestor = function (tree, sourceId, targetId) {\n    if (targetId === 0) {\n        return false;\n    }\n    var targetNode = tree.find(function (node) { return node.id === targetId; });\n    if (targetNode === undefined) {\n        return false;\n    }\n    if (targetNode.parent === sourceId) {\n        return true;\n    }\n    return isAncestor(tree, sourceId, targetNode.parent);\n};\n\nvar isDroppable = function (dragSourceId, dropTargetId, treeContext) {\n    var tree = treeContext.tree, rootId = treeContext.rootId, canDrop = treeContext.canDrop;\n    if (dragSourceId === undefined) {\n        if (dropTargetId === rootId) {\n            return true;\n        }\n        var dropTargetNode = tree.find(function (node) { return node.id === dropTargetId; });\n        if (dropTargetNode && dropTargetNode.droppable) {\n            return true;\n        }\n        return false;\n    }\n    else {\n        if (canDrop) {\n            var result = canDrop(dragSourceId, dropTargetId);\n            if (result !== undefined) {\n                return result;\n            }\n        }\n        if (dragSourceId === dropTargetId) {\n            return false;\n        }\n        var dragSourceNode = tree.find(function (node) { return node.id === dragSourceId; });\n        if (dragSourceNode === undefined ||\n            dragSourceNode.parent === dropTargetId) {\n            return false;\n        }\n        if (dropTargetId === rootId) {\n            return true;\n        }\n        var dropTargetNode = tree.find(function (node) { return node.id === dropTargetId; });\n        if (dropTargetNode === undefined || !dropTargetNode.droppable) {\n            return false;\n        }\n        return !isAncestor(tree, dragSourceId, dropTargetId);\n    }\n};\n\nvar getDestinationIndex = function (tree, dropTargetId, index) {\n    if (index === 0) {\n        return 0;\n    }\n    var siblings = tree.filter(function (node) { return node.parent === dropTargetId; });\n    if (siblings[index]) {\n        return tree.findIndex(function (node) { return node.id === siblings[index].id; });\n    }\n    return tree.findIndex(function (node) { return node.id === siblings[index - 1].id; }) + 1;\n};\nvar arrayMoveMutable = function (array, fromIndex, toIndex) {\n    var startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < array.length) {\n        var endIndex = toIndex < 0 ? array.length + toIndex : toIndex;\n        var item = array.splice(fromIndex, 1)[0];\n        array.splice(endIndex, 0, item);\n    }\n};\nvar arrayMoveImmutable = function (array, fromIndex, toIndex) {\n    array = __spreadArray([], array);\n    arrayMoveMutable(array, fromIndex, toIndex);\n    return array;\n};\nvar mutateTree = function (tree, dragSourceId, dropTargetId, index) {\n    var srcIndex = tree.findIndex(function (node) { return node.id === dragSourceId; });\n    var destIndex = getDestinationIndex(tree, dropTargetId, index);\n    var newTree;\n    if (destIndex > srcIndex) {\n        newTree = arrayMoveImmutable(tree, srcIndex, destIndex - 1);\n    }\n    else {\n        newTree = arrayMoveImmutable(tree, srcIndex, destIndex);\n    }\n    return produce(newTree, function (draft) {\n        draft.forEach(function (node) {\n            if (node.id === dragSourceId) {\n                node.parent = dropTargetId;\n            }\n        });\n    });\n};\n\nvar compareYCoord = function (el, pointerY) {\n    var bbox = el.getBoundingClientRect();\n    var centerY = bbox.top + bbox.height / 2;\n    return pointerY > centerY ? \"down\" : \"up\";\n};\nvar getInnerIndex = function (listItems, monitor) {\n    var pos = \"\";\n    var index = 0;\n    listItems.forEach(function (el, key) {\n        var _a;\n        var flag = compareYCoord(el, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0);\n        if (pos === \"\") {\n            pos = flag;\n        }\n        else if (pos !== flag) {\n            pos = flag;\n            index = key;\n        }\n        if (key === listItems.length - 1 && flag === \"down\") {\n            index = key + 1;\n        }\n    });\n    return index;\n};\nvar getOuterIndex = function (node, nodeEl, monitor) {\n    var parentList = nodeEl.closest('[role=\"list\"]');\n    var parentListItems = parentList === null || parentList === void 0 ? void 0 : parentList.querySelectorAll(':scope > [role=\"listitem\"]');\n    if (!parentListItems) {\n        return null;\n    }\n    return getInnerIndex(parentListItems, monitor);\n};\nvar getHoverPosition = function (el, pointerY, context) {\n    var bbox = el.getBoundingClientRect();\n    var offsetY = context.dropTargetOffset;\n    var upSideY = bbox.top + offsetY;\n    var lowerSideY = bbox.bottom - offsetY;\n    if (pointerY > lowerSideY) {\n        return \"lower\";\n    }\n    else if (pointerY < upSideY) {\n        return \"upper\";\n    }\n    return \"middle\";\n};\nvar getDropTarget = function (node, nodeEl, monitor, context) {\n    var _a;\n    if (!nodeEl) {\n        return null;\n    }\n    if (node === null) {\n        var listItems = nodeEl.querySelectorAll(':scope > [role=\"listitem\"]');\n        return {\n            id: context.rootId,\n            index: getInnerIndex(listItems, monitor),\n        };\n    }\n    var dragSource = monitor.getItem();\n    var list = nodeEl.querySelector('[role=\"list\"]');\n    var hoverPosition = getHoverPosition(nodeEl, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0, context);\n    if (!list) {\n        if (hoverPosition === \"middle\") {\n            return {\n                id: node.id,\n                index: 0,\n            };\n        }\n        if (isDroppable(dragSource.id, node.parent, context)) {\n            var outerIndex = getOuterIndex(node, nodeEl, monitor);\n            if (outerIndex === null) {\n                return null;\n            }\n            return {\n                id: node.parent,\n                index: outerIndex,\n            };\n        }\n        return null;\n    }\n    else {\n        if (hoverPosition === \"upper\") {\n            if (isDroppable(dragSource.id, node.parent, context)) {\n                var outerIndex = getOuterIndex(node, nodeEl, monitor);\n                if (outerIndex === null) {\n                    return null;\n                }\n                return {\n                    id: node.parent,\n                    index: outerIndex,\n                };\n            }\n            else {\n                return {\n                    id: node.id,\n                    index: 0,\n                };\n            }\n        }\n        var listItems = list.querySelectorAll(':scope > [role=\"listitem\"]');\n        return {\n            id: node.id,\n            index: getInnerIndex(listItems, monitor),\n        };\n    }\n};\n\nvar TreeContext = React.createContext({});\nvar TreeProvider = function (props) {\n    var _a = useOpenIdsHelper(props.tree, props.initialOpen), openIds = _a[0], _b = _a[1], handleToggle = _b.handleToggle, handleCloseAll = _b.handleCloseAll, handleOpenAll = _b.handleOpenAll, handleOpen = _b.handleOpen, handleClose = _b.handleClose;\n    useImperativeHandle(props.treeRef, function () { return ({\n        open: function (targetIds) { return handleOpen(targetIds); },\n        close: function (targetIds) { return handleClose(targetIds); },\n        openAll: function () { return handleOpenAll(); },\n        closeAll: function () { return handleCloseAll(); },\n    }); });\n    var canDropCallback = props.canDrop;\n    var canDragCallback = props.canDrag;\n    var value = __assign(__assign({ listComponent: \"ul\", listItemComponent: \"li\", placeholderComponent: \"li\", sort: true, insertDroppableFirst: true, dropTargetOffset: 0, initialOpen: false }, props), { openIds: openIds, onDrop: function (id, parentId, index) {\n            return props.onDrop(mutateTree(props.tree, id, parentId, index), {\n                dragSourceId: id,\n                dropTargetId: parentId,\n                dragSource: getTreeItem(props.tree, id),\n                dropTarget: getTreeItem(props.tree, parentId),\n            });\n        }, canDrop: canDropCallback\n            ? function (id, parentId) {\n                return canDropCallback(props.tree, {\n                    dragSourceId: id,\n                    dropTargetId: parentId,\n                    dragSource: getTreeItem(props.tree, id),\n                    dropTarget: getTreeItem(props.tree, parentId),\n                });\n            }\n            : undefined, canDrag: canDragCallback\n            ? function (id) { return canDragCallback(getTreeItem(props.tree, id)); }\n            : undefined, onToggle: handleToggle });\n    return (React.createElement(TreeContext.Provider, { value: value }, props.children));\n};\n\nvar DragControlContext = React.createContext({});\nvar initialState$1 = {\n    isLock: false,\n};\nvar DragControlProvider = function (props) {\n    var _a = useState(initialState$1.isLock), isLock = _a[0], setIsLock = _a[1];\n    return (React.createElement(DragControlContext.Provider, { value: {\n            isLock: isLock,\n            lock: function () { return setIsLock(true); },\n            unlock: function () { return setIsLock(false); },\n        } }, props.children));\n};\n\nvar PlaceholderContext = React.createContext({});\nvar initialState = {\n    dropTargetId: undefined,\n    index: undefined,\n};\nvar PlaceholderProvider = function (props) {\n    var _a = useState(initialState.dropTargetId), dropTargetId = _a[0], setDropTargetId = _a[1];\n    var _b = useState(initialState.index), index = _b[0], setIndex = _b[1];\n    var showPlaceholder = function (dropTargetId, index) {\n        setDropTargetId(dropTargetId);\n        setIndex(index);\n    };\n    var hidePlaceholder = function () {\n        setDropTargetId(initialState.dropTargetId);\n        setIndex(initialState.index);\n    };\n    return (React.createElement(PlaceholderContext.Provider, { value: {\n            dropTargetId: dropTargetId,\n            index: index,\n            showPlaceholder: showPlaceholder,\n            hidePlaceholder: hidePlaceholder,\n        } }, props.children));\n};\n\nvar Providers = function (props) { return (React.createElement(TreeProvider, __assign({}, props),\n    React.createElement(DragControlProvider, null,\n        React.createElement(PlaceholderProvider, null,\n            React.createElement(DndProvider, { options: HTML5toTouch }, props.children))))); };\n\n/**\n * This is a hook to allow text selection by mouse in the text input area in a node.\n * Temporarily disables node dragging while the pointer is over the text input area.\n */\nvar useDragControl = function (ref) {\n    var dragControlContext = useContext(DragControlContext);\n    var lock = function (e) {\n        var target = e.target;\n        if (target instanceof HTMLInputElement ||\n            target instanceof HTMLTextAreaElement) {\n            dragControlContext.lock();\n        }\n    };\n    var unlock = function (e) {\n        var target = e.target;\n        if (target instanceof HTMLInputElement ||\n            target instanceof HTMLTextAreaElement) {\n            dragControlContext.unlock();\n        }\n    };\n    var handleMouseOver = function (e) { return lock(e); };\n    var handleMouseOut = function (e) { return unlock(e); };\n    var handleFocusIn = function (e) { return lock(e); };\n    var handleFocusOut = function (e) { return unlock(e); };\n    useEffect(function () {\n        var _a, _b, _c, _d;\n        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener(\"mouseover\", handleMouseOver);\n        (_b = ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener(\"mouseout\", handleMouseOut);\n        (_c = ref.current) === null || _c === void 0 ? void 0 : _c.addEventListener(\"focusin\", handleFocusIn);\n        (_d = ref.current) === null || _d === void 0 ? void 0 : _d.addEventListener(\"focusout\", handleFocusOut);\n        return function () {\n            var _a, _b, _c, _d;\n            (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"mouseover\", handleMouseOver);\n            (_b = ref.current) === null || _b === void 0 ? void 0 : _b.removeEventListener(\"mouseout\", handleMouseOut);\n            (_c = ref.current) === null || _c === void 0 ? void 0 : _c.removeEventListener(\"focusin\", handleFocusIn);\n            (_d = ref.current) === null || _d === void 0 ? void 0 : _d.removeEventListener(\"focusout\", handleFocusOut);\n        };\n    }, []);\n    useEffect(function () {\n        var _a;\n        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.setAttribute(\"draggable\", dragControlContext.isLock ? \"false\" : \"true\");\n    }, [dragControlContext.isLock]);\n};\n\nvar ItemTypes = {\n    TREE_ITEM: Symbol(),\n};\n\nvar dragSourceElement = null;\nvar useDragNode = function (item, ref) {\n    var treeContext = useTreeContext();\n    var register = function (e) {\n        var target = e.target;\n        if (target instanceof HTMLElement) {\n            var source = target.closest('[role=\"listitem\"]');\n            if (e.currentTarget === source) {\n                dragSourceElement = source;\n            }\n        }\n    };\n    var handleDragStart = function (e) { return register(e); };\n    var handleTouchStart = function (e) { return register(e); };\n    useEffect(function () {\n        var _a, _b;\n        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener(\"dragstart\", handleDragStart);\n        (_b = ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener(\"touchstart\", handleTouchStart, {\n            passive: true,\n        });\n        return function () {\n            var _a, _b;\n            (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"dragstart\", handleDragStart);\n            (_b = ref.current) === null || _b === void 0 ? void 0 : _b.removeEventListener(\"touchstart\", handleTouchStart);\n        };\n    }, []);\n    var _a = useDrag({\n        type: ItemTypes.TREE_ITEM,\n        item: __assign({ ref: ref }, item),\n        canDrag: function () {\n            var canDrag = treeContext.canDrag;\n            if (dragSourceElement !== ref.current) {\n                return false;\n            }\n            if (canDrag) {\n                return canDrag(item.id);\n            }\n            return true;\n        },\n        collect: function (monitor) { return ({\n            isDragging: monitor.isDragging(),\n        }); },\n    }), isDragging = _a[0].isDragging, drag = _a[1], preview = _a[2];\n    return [isDragging, drag, preview];\n};\n\nvar useDragOver = function (id, isOpen, dragOverHandler) {\n    var stack = useRef(0);\n    var timer = useRef(0);\n    var onDragEnter = function () {\n        stack.current += 1;\n        if (stack.current === 1 && !isOpen) {\n            timer.current = window.setTimeout(function () { return dragOverHandler(id); }, 500);\n        }\n    };\n    var onDragLeave = function () {\n        stack.current -= 1;\n        if (stack.current === 0) {\n            window.clearTimeout(timer.current);\n        }\n    };\n    var onDrop = function () {\n        if (timer.current > 0) {\n            window.clearTimeout(timer.current);\n        }\n        stack.current = 0;\n        timer.current = 0;\n    };\n    return {\n        onDragEnter: onDragEnter,\n        onDragLeave: onDragLeave,\n        onDrop: onDrop,\n    };\n};\n\nvar useDropRoot = function (ref) {\n    var treeContext = useTreeContext();\n    var placeholderContext = useContext(PlaceholderContext);\n    var _a = useDrop({\n        accept: ItemTypes.TREE_ITEM,\n        drop: function (item, monitor) {\n            var rootId = treeContext.rootId, onDrop = treeContext.onDrop;\n            var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index;\n            if (monitor.isOver({ shallow: true }) &&\n                dropTargetId !== undefined &&\n                index !== undefined) {\n                onDrop(item.id, rootId, index);\n            }\n            placeholderContext.hidePlaceholder();\n        },\n        canDrop: function (item, monitor) {\n            var rootId = treeContext.rootId;\n            if (monitor.isOver({ shallow: true })) {\n                if (item === undefined) {\n                    return false;\n                }\n                return isDroppable(item.id, rootId, treeContext);\n            }\n            return false;\n        },\n        hover: function (dragItem, monitor) {\n            if (monitor.isOver({ shallow: true })) {\n                var rootId = treeContext.rootId;\n                var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index, showPlaceholder = placeholderContext.showPlaceholder, hidePlaceholder = placeholderContext.hidePlaceholder;\n                var dropTarget = getDropTarget(null, ref.current, monitor, treeContext);\n                if (dropTarget === null ||\n                    !isDroppable(dragItem.id, rootId, treeContext)) {\n                    hidePlaceholder();\n                    return;\n                }\n                if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n                    showPlaceholder(dropTarget.id, dropTarget.index);\n                }\n            }\n        },\n        collect: function (monitor) { return ({\n            isOver: monitor.isOver({ shallow: true }) && monitor.canDrop(),\n            dragSource: monitor.getItem(),\n        }); },\n    }), _b = _a[0], isOver = _b.isOver, dragSource = _b.dragSource, drop = _a[1];\n    return [isOver, dragSource, drop];\n};\n\nvar useDropNode = function (item, ref) {\n    var treeContext = useTreeContext();\n    var placeholderContext = useContext(PlaceholderContext);\n    var _a = useDrop({\n        accept: ItemTypes.TREE_ITEM,\n        drop: function (dragSource, monitor) {\n            var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index;\n            if (monitor.isOver({ shallow: true }) &&\n                dropTargetId !== undefined &&\n                index !== undefined) {\n                treeContext.onDrop(dragSource.id, dropTargetId, index);\n            }\n            placeholderContext.hidePlaceholder();\n        },\n        canDrop: function (dragSource, monitor) {\n            if (monitor.isOver({ shallow: true })) {\n                var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n                if (dropTarget === null) {\n                    return false;\n                }\n                return isDroppable(dragSource.id, dropTarget.id, treeContext);\n            }\n            return false;\n        },\n        hover: function (dragSource, monitor) {\n            if (monitor.isOver({ shallow: true })) {\n                var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index, showPlaceholder = placeholderContext.showPlaceholder, hidePlaceholder = placeholderContext.hidePlaceholder;\n                var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n                if (dropTarget === null ||\n                    !isDroppable(dragSource.id, dropTarget.id, treeContext)) {\n                    hidePlaceholder();\n                    return;\n                }\n                if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n                    showPlaceholder(dropTarget.id, dropTarget.index);\n                }\n            }\n        },\n        collect: function (monitor) { return ({\n            isOver: monitor.isOver({ shallow: true }) && monitor.canDrop(),\n            dragSource: monitor.getItem(),\n        }); },\n    }), _b = _a[0], isOver = _b.isOver, dragSource = _b.dragSource, drop = _a[1];\n    return [isOver, dragSource, drop];\n};\n\nvar useOpenIdsHelper = function (tree, initialOpen) {\n    var initialOpenIds = [];\n    if (initialOpen === true) {\n        initialOpenIds = tree\n            .filter(function (node) { return node.droppable; })\n            .map(function (node) { return node.id; });\n    }\n    else if (Array.isArray(initialOpen)) {\n        initialOpenIds = initialOpen;\n    }\n    var _a = useState(initialOpenIds), openIds = _a[0], setOpenIds = _a[1];\n    var handleToggle = useCallback(function (targetId) {\n        if (openIds.includes(targetId)) {\n            setOpenIds(openIds.filter(function (id) { return id !== targetId; }));\n            return;\n        }\n        setOpenIds(__spreadArray(__spreadArray([], openIds), [targetId]));\n    }, [openIds]);\n    var handleCloseAll = useCallback(function () { return setOpenIds([]); }, []);\n    var handleOpenAll = useCallback(function () {\n        return setOpenIds(tree.filter(function (node) { return node.droppable; }).map(function (node) { return node.id; }));\n    }, [tree]);\n    var handleOpen = useCallback(function (targetIds) {\n        return setOpenIds(__spreadArray(__spreadArray([], openIds), tree\n            .filter(function (node) {\n            return node.droppable &&\n                (Array.isArray(targetIds)\n                    ? targetIds.includes(node.id)\n                    : node.id === targetIds);\n        })\n            .map(function (node) { return node.id; })).filter(function (value, index, self) { return self.indexOf(value) === index; }));\n    }, [tree, openIds]);\n    var handleClose = useCallback(function (targetIds) {\n        return setOpenIds(openIds.filter(function (id) {\n            return Array.isArray(targetIds) ? !targetIds.includes(id) : id !== targetIds;\n        }));\n    }, [tree, openIds]);\n    return [\n        openIds,\n        { handleToggle: handleToggle, handleCloseAll: handleCloseAll, handleOpenAll: handleOpenAll, handleOpen: handleOpen, handleClose: handleClose },\n    ];\n};\n\nvar useTreeDragLayer = function () {\n    return useDragLayer(function (monitor) {\n        var itemType = monitor.getItemType();\n        return {\n            item: monitor.getItem(),\n            clientOffset: monitor.getClientOffset(),\n            isDragging: monitor.isDragging() && itemType === ItemTypes.TREE_ITEM,\n        };\n    });\n};\n\nvar useTreeContext = function () {\n    var treeContext = useContext(TreeContext);\n    if (!treeContext) {\n        throw new Error(\"useTreeContext must be used under TreeProvider\");\n    }\n    return treeContext;\n};\n\nvar Node = function (props) {\n    var context = useTreeContext();\n    var ref = useRef(null);\n    var item = context.tree.find(function (node) { return node.id === props.id; });\n    var openIds = context.openIds, classes = context.classes;\n    var open = openIds.includes(props.id);\n    if (!item) {\n        return null;\n    }\n    var _a = useDragNode(item, ref), isDragging = _a[0], drag = _a[1], preview = _a[2];\n    var _b = useDropNode(item, ref), isOver = _b[0], dragSource = _b[1], drop = _b[2];\n    drag(ref);\n    if (isDroppable(dragSource === null || dragSource === void 0 ? void 0 : dragSource.id, props.id, context)) {\n        drop(ref);\n    }\n    var hasChild = !!context.tree.find(function (node) { return node.parent === props.id; });\n    useEffect(function () {\n        if (context.dragPreviewRender) {\n            preview(getEmptyImage(), { captureDraggingState: true });\n        }\n    }, []);\n    useDragControl(ref);\n    var handleToggle = useCallback(function () {\n        context.onToggle(item.id);\n    }, [openIds]);\n    var Component = context.listItemComponent;\n    var className = \"\";\n    if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n        className = classes.dropTarget;\n    }\n    if (isDragging && (classes === null || classes === void 0 ? void 0 : classes.draggingSource)) {\n        className = className + \" \" + classes.draggingSource;\n    }\n    var draggable = context.canDrag ? context.canDrag(props.id) : true;\n    var params = {\n        depth: props.depth,\n        isOpen: open,\n        draggable: draggable,\n        hasChild: hasChild,\n        onToggle: handleToggle,\n    };\n    return (React.createElement(Component, { ref: ref, className: className, role: \"listitem\" },\n        context.render(item, params),\n        open && hasChild && (React.createElement(Container, { parentId: props.id, depth: props.depth + 1 }))));\n};\n\nvar Placeholder = function (props) {\n    var _a = useTreeContext(), placeholderRender = _a.placeholderRender, Component = _a.placeholderComponent, classes = _a.classes;\n    var placeholderContext = useContext(PlaceholderContext);\n    var manager = useDragDropManager();\n    var monitor = manager.getMonitor();\n    var dragSource = monitor.getItem();\n    if (!placeholderRender || !dragSource) {\n        return null;\n    }\n    var visible = props.dropTargetId === placeholderContext.dropTargetId &&\n        (props.index === placeholderContext.index ||\n            (props.index === undefined &&\n                props.listCount === placeholderContext.index));\n    if (!visible) {\n        return null;\n    }\n    return (React.createElement(Component, { className: (classes === null || classes === void 0 ? void 0 : classes.placeholder) || \"\" }, placeholderRender(dragSource, { depth: props.depth })));\n};\n\nvar Container = function (props) {\n    var treeContext = useTreeContext();\n    var ref = useRef(null);\n    var nodes = treeContext.tree.filter(function (l) { return l.parent === props.parentId; });\n    var view = nodes;\n    var sortCallback = typeof treeContext.sort === \"function\" ? treeContext.sort : compareItems;\n    if (treeContext.insertDroppableFirst) {\n        var droppableNodes = nodes.filter(function (n) { return n.droppable; });\n        var nonDroppableNodes = nodes.filter(function (n) { return !n.droppable; });\n        if (treeContext.sort === false) {\n            view = __spreadArray(__spreadArray([], droppableNodes), nonDroppableNodes);\n        }\n        else {\n            droppableNodes = droppableNodes.sort(sortCallback);\n            nonDroppableNodes = nonDroppableNodes.sort(sortCallback);\n            view = __spreadArray(__spreadArray([], droppableNodes), nonDroppableNodes);\n        }\n    }\n    else {\n        if (treeContext.sort !== false) {\n            view = nodes.sort(sortCallback);\n        }\n    }\n    var _a = useDropRoot(ref), isOver = _a[0], dragSource = _a[1], drop = _a[2];\n    var classes = treeContext.classes;\n    if (props.parentId === treeContext.rootId &&\n        isDroppable(dragSource === null || dragSource === void 0 ? void 0 : dragSource.id, treeContext.rootId, treeContext)) {\n        drop(ref);\n    }\n    var className = \"\";\n    if (classes === null || classes === void 0 ? void 0 : classes.container) {\n        className = classes.container;\n    }\n    if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n        className = className + \" \" + classes.dropTarget;\n    }\n    if (props.parentId === 0 && (classes === null || classes === void 0 ? void 0 : classes.root)) {\n        className = className + \" \" + classes.root;\n    }\n    var Component = treeContext.listComponent;\n    return (React.createElement(Component, { ref: ref, className: className, role: \"list\" },\n        view.map(function (node, index) { return (React.createElement(React.Fragment, { key: node.id },\n            React.createElement(Placeholder, { depth: props.depth, listCount: view.length, dropTargetId: props.parentId, index: index }),\n            React.createElement(Node, { id: node.id, depth: props.depth }))); }),\n        React.createElement(Placeholder, { depth: props.depth, listCount: view.length, dropTargetId: props.parentId })));\n};\n\nvar rootStyle = {\n    height: \"100%\",\n    left: 0,\n    pointerEvents: \"none\",\n    position: \"fixed\",\n    top: 0,\n    width: \"100%\",\n    zIndex: 100,\n};\nvar getItemStyles = function (monitorProps) {\n    var offset = monitorProps.clientOffset;\n    if (!offset) {\n        return {};\n    }\n    var x = offset.x, y = offset.y;\n    var transform = \"translate(\" + x + \"px, \" + y + \"px)\";\n    return {\n        pointerEvents: \"none\",\n        transform: transform,\n    };\n};\nvar DragLayer = function () {\n    var context = useTreeContext();\n    var monitorProps = useTreeDragLayer();\n    if (!monitorProps.isDragging) {\n        return null;\n    }\n    return (React.createElement(\"div\", { style: rootStyle },\n        React.createElement(\"div\", { style: getItemStyles(monitorProps) }, context.dragPreviewRender && context.dragPreviewRender(monitorProps))));\n};\n\nfunction TreeInner(props, ref) {\n    return (React.createElement(Providers, __assign({}, props, { treeRef: ref }),\n        props.dragPreviewRender && React.createElement(DragLayer, null),\n        React.createElement(Container, { parentId: props.rootId, depth: 0 })));\n}\nvar Tree = forwardRef(TreeInner);\n\nexport { Container, DragLayer, ItemTypes, Node, Tree, compareItems, getDropTarget, getTreeItem, isAncestor, isDroppable, mutateTree, useDragControl, useDragNode, useDragOver, useDropNode, useDropRoot, useOpenIdsHelper, useTreeContext, useTreeDragLayer };\n//# sourceMappingURL=index.esm.js.map\n"]},"metadata":{},"sourceType":"module"}